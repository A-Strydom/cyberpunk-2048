<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A cyberpunk-themed 2048 puzzle game with neon visuals, smooth animations, and AI autodrive mode. Play now!">
  <meta name="keywords" content="2048, puzzle game, cyberpunk, neon, game, html5">
  <meta name="author" content="">
  <title>Cyberpunk 2048 - Neon Puzzle Game</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3Cfilter id='cyanGlow' x='-50%25' y='-50%25' width='200%25' height='200%25'%3E%3CfeGaussianBlur stdDeviation='2' result='coloredBlur'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3Cfilter id='yellowGlow' x='-50%25' y='-50%25' width='200%25' height='200%25'%3E%3CfeGaussianBlur stdDeviation='2.5' result='coloredBlur'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3Cfilter id='pinkGlow' x='-150%25' y='-150%25' width='400%25' height='400%25'%3E%3CfeGaussianBlur stdDeviation='5' result='coloredBlur'/%3E%3CfeGaussianBlur in='SourceGraphic' stdDeviation='2.5' result='coloredBlur2'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='coloredBlur2'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3Cfilter id='cyanBorderGlow' x='-50%25' y='-50%25' width='200%25' height='200%25'%3E%3CfeGaussianBlur stdDeviation='3' result='coloredBlur'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3Cfilter id='pinkNeonGlow' x='-200%25' y='-200%25' width='500%25' height='500%25'%3E%3CfeGaussianBlur stdDeviation='6' result='coloredBlur'/%3E%3CfeColorMatrix in='coloredBlur' type='matrix' values='1 0 0 0 1 0 0 0 0.25 0 0 0 0 0.63 0 0 0 0 1 0'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg filter='url(%23pinkNeonGlow)'%3E%3Crect width='100' height='100' fill='%230a030a'/%3E%3Cg%3E%3Crect x='5' y='5' width='28' height='28' fill='rgba(15,10,25,0.4)' rx='2'/%3E%3Crect x='36' y='5' width='28' height='28' fill='%2300f5ff' filter='url(%23cyanGlow)' rx='2' opacity='0.9'/%3E%3Crect x='67' y='5' width='28' height='28' fill='%23ff00ff' filter='url(%23pinkGlow)' rx='2' opacity='1'/%3E%3Crect x='5' y='36' width='28' height='28' fill='%2300d0e0' filter='url(%23cyanGlow)' rx='2' opacity='0.85'/%3E%3Crect x='36' y='36' width='28' height='28' fill='rgba(15,10,25,0.4)' rx='2'/%3E%3Crect x='67' y='36' width='28' height='28' fill='rgba(15,10,25,0.4)' rx='2'/%3E%3Crect x='5' y='67' width='28' height='28' fill='%23ffeb3b' filter='url(%23yellowGlow)' rx='2' opacity='0.95'/%3E%3Crect x='36' y='67' width='28' height='28' fill='%2300d0e0' filter='url(%23cyanGlow)' rx='2' opacity='0.85'/%3E%3Crect x='67' y='67' width='28' height='28' fill='rgba(15,10,25,0.4)' rx='2'/%3E%3C/g%3E%3Crect x='1' y='1' width='98' height='98' fill='none' stroke='%2300f5ff' stroke-width='1.5' opacity='0.5' rx='3'/%3E%3Crect x='2' y='2' width='96' height='96' fill='none' stroke='%2300f5ff' stroke-width='2' filter='url(%23cyanBorderGlow)' rx='3'/%3E%3C/g%3E%3Crect x='-2' y='-2' width='104' height='104' fill='none' stroke='%23ff0040' stroke-width='2' opacity='0.6' rx='6'/%3E%3Crect x='-3' y='-3' width='106' height='106' fill='none' stroke='%23ff0040' stroke-width='1' opacity='0.4' rx='7'/%3E%3C/svg%3E" type="image/svg+xml">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Sixtyfour&display=swap" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(135deg, #1a0a1f 0%, #0f0515 30%, #0a030a 60%, #000000 100%);
      font-family: 'Share Tech Mono', monospace;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #0ff;
      overflow: hidden;
      text-shadow: 0 0 8px #0ff;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.15) 1px, transparent 0),
        radial-gradient(circle at 2px 2px, rgba(0, 0, 0, 0.2) 1px, transparent 0),
        radial-gradient(circle at 3px 3px, rgba(255, 255, 255, 0.1) 1px, transparent 0);
      background-size: 4px 4px, 3px 3px, 5px 5px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
      mix-blend-mode: overlay;
    }
    #backgroundEffects {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      opacity: 0.4;
    }
    .code-stream {
      position: fixed;
      left: 20px;
      top: 0;
      width: 60px;
      height: 100%;
      font-size: 9px;
      color: rgba(200, 200, 200, 0.25);
      font-family: 'Share Tech Mono', monospace;
      line-height: 1.3;
      overflow: hidden;
      z-index: 1;
    }
    .code-stream::before {
      content: '0x1A2B\A 0x3C4D\A 0x5E6F\A 0x7890\A 0xABCD\A 0xEF01\A 0x2345\A 0x6789\A 0xFEDC\A 0xBA98\A 0x7654\A 0x3210\A 0x9ABC\A 0xDEF0\A 0x1234\A 0x5678\A 0x9ABC\A 0xDEF0\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF\A 0x0246\A 0x8ACE\A 0x1357\A 0x9BDF\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF';
      white-space: pre;
      display: block;
    }
    .text-artifacts {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.15;
    }
    .text-artifacts::before {
      content: 'ERR_0x1A2B\A DATA_CORRUPT\A SYS_FAIL\A INIT_SEQ\A LOAD_FAIL\A MEM_ERR\A PROC_TERM\A EXEC_ERR\A STACK_OVF\A NULL_PTR\A ACCESS_DEN\A INVALID_OP\A TIMEOUT\A DEADLOCK\A RACE_COND\A BUFFER_OVF';
      position: absolute;
      top: 10%;
      left: 15%;
      font-size: 7px;
      color: rgba(150, 150, 150, 0.35);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.4;
      transform: rotate(-1.5deg);
    }
    .text-artifacts::after {
      content: '[192.168.1.42]\A [10.0.0.15]\A [172.16.0.8]\A PORT:8080\A PORT:443\A PORT:22\A PID:1234\A PID:5678\A PID:9012\A /usr/bin/\A /var/log/\A /tmp/data\A /sys/kernel\A /proc/self\A /dev/null\A /etc/config';
      position: absolute;
      bottom: 20%;
      right: 10%;
      font-size: 8px;
      color: rgba(180, 180, 180, 0.3);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.5;
      transform: rotate(1deg);
    }
    .text-artifacts-extra {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.12;
    }
    .text-artifacts-extra::before {
      content: '> INIT\A > LOAD\A > EXEC\A > TERM\A > EXIT\A > WAIT\A > SYNC\A > FLUSH\A > CLEAR\A > RESET\A > START\A > STOP\A > PAUSE\A > RESUME\A > KILL';
      position: absolute;
      top: 60%;
      left: 8%;
      font-size: 6px;
      color: rgba(140, 140, 140, 0.4);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.6;
      transform: rotate(0.8deg);
    }
    .text-artifacts-extra::after {
      content: '0xDEADBEEF\A 0xCAFEBABE\A 0xFEEDFACE\A 0xBADC0FFE\A 0xBAADF00D\A 0xABADBABE\A 0xDEADC0DE\A 0x00000000\A 0xFFFFFFFF\A 0x12345678\A 0x87654321\A 0xABCDEF00\A 0x00FEDCBA\A 0x11223344\A 0x55667788';
      position: absolute;
      top: 25%;
      right: 15%;
      font-size: 7px;
      color: rgba(160, 160, 160, 0.3);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.5;
      transform: rotate(-0.5deg);
    }
    .geometric-lines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.2;
    }
    .geometric-lines::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(90deg, rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px),
        linear-gradient(-45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px);
      background-size: 50px 50px, 50px 50px, 100px 100px, 100px 100px;
      background-position: 0 0, 0 0, 0 0, 0 0;
    }
    .geometric-lines::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(circle at 30% 30%, rgba(0, 245, 255, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 70% 70%, rgba(255, 0, 64, 0.08) 0%, transparent 50%);
    }
    #ui {
      display: none;
    }
    .top-right-controls {
      position: fixed;
      top: 40px;
      right: 80px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 100;
    }
    #restart {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #restart::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #restart::after {
      content: '⚡';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
    }
    #restart:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #restart.clicking {
      animation: buttonGlitch 0.4s ease;
    }
    @keyframes buttonGlitch {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-2px) translateY(1px); }
      20% { transform: translateX(2px) translateY(-1px); }
      30% { transform: translateX(-1px) translateY(2px); }
      40% { transform: translateX(1px) translateY(-2px); }
      50% { transform: translateX(-2px); }
      60% { transform: translateX(2px); }
      70% { transform: translateX(-1px); }
      80% { transform: translateX(1px); }
    }
    canvas.glitching {
      animation: boardGlitch 0.5s ease;
    }
    @keyframes boardGlitch {
      0%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
      5% { 
        transform: translateX(-3px) translateY(2px);
        filter: hue-rotate(90deg);
      }
      10% { 
        transform: translateX(3px) translateY(-2px);
        filter: hue-rotate(-90deg);
      }
      15% { 
        transform: translateX(-2px) translateY(3px);
        filter: hue-rotate(180deg);
      }
      20% { 
        transform: translateX(2px) translateY(-3px);
        filter: hue-rotate(-180deg);
      }
      25% { 
        transform: translateX(-4px) translateY(1px);
        filter: hue-rotate(45deg);
      }
      30% { 
        transform: translateX(4px) translateY(-1px);
        filter: hue-rotate(-45deg);
      }
      35% { 
        transform: translateX(-1px) translateY(4px);
        filter: hue-rotate(135deg);
      }
      40% { 
        transform: translateX(1px) translateY(-4px);
        filter: hue-rotate(-135deg);
      }
      45% { 
        transform: translateX(-3px);
        filter: hue-rotate(90deg);
      }
      50% { 
        transform: translateX(3px);
        filter: hue-rotate(-90deg);
      }
      55% { 
        transform: translateX(-2px);
        filter: hue-rotate(0deg);
      }
      60% { 
        transform: translateX(2px);
        filter: hue-rotate(0deg);
      }
      65%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
    }
    .score-display {
      position: absolute;
      top: -50px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      text-align: center;
      pointer-events: none;
    }
    .score-display strong {
      font-size: 32px;
      color: #00f5ff;
      text-shadow: 0 0 10px #00f5ff, 0 0 20px rgba(0, 245, 255, 0.5);
      font-family: 'Share Tech Mono', monospace;
    }
    .high-score-system {
      position: fixed;
      bottom: 40px;
      right: 80px;
      z-index: 100;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      color: rgba(150, 150, 150, 0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .high-score-system::before {
      content: '[SYS] ';
      color: rgba(0, 245, 255, 0.5);
    }
    .high-score-system strong {
      color: rgba(0, 245, 255, 0.7);
      font-weight: normal;
    }
    canvas {
      background: rgba(10, 10, 30, 0.3);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), 0 0 40px rgba(255, 0, 255, 0.3), inset 0 0 12px rgba(0, 245, 255, 0.3);
      border: 2px solid rgba(0, 245, 255, 0.75);
      border-radius: 12px;
      image-rendering: pixelated;
      display: block;
      position: relative;
      z-index: 10;
    }
    #game-container {
      position: relative;
      display: inline-block;
    }
    #gameOver {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 0, 17, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    #gameOver.show {
      display: flex;
    }
    .game-over-content {
      text-align: center;
    }
    .flatlined-text {
      font-size: 72px;
      font-weight: bold;
      color: #ff0040;
      text-shadow: 
        0 0 8px #ff0040,
        0 0 15px #ff0040;
      margin-bottom: 20px;
      letter-spacing: 8px;
    }
    .game-over-subtitle {
      font-size: 24px;
      color: #ff0040;
      text-shadow: 0 0 10px #ff0040;
      margin-bottom: 30px;
    }
    .final-score {
      font-size: 32px;
      color: #00f5ff;
      text-shadow: 0 0 15px #00f5ff;
      margin-bottom: 40px;
    }
    .final-score span {
      display: block;
      font-size: 18px;
      color: #00f5ff;
      margin-top: 10px;
    }
    #restartGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      padding: 15px 40px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
    }
    #restartGame:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #f0f;
      border-color: #f0f;
      box-shadow: 0 0 25px #f0f;
      transform: scale(1.1);
      text-shadow: 0 0 15px #f0f;
    }
    #autodrive {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease, border-color 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #autodrive::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #autodrive::after {
      content: '▶';
      font-size: 12px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
    }
    #autodrive:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #autodrive.active {
      background: rgba(0, 245, 255, 0.15);
      border-color: #00f5ff;
      color: #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.6);
      text-shadow: 0 0 10px #00f5ff;
    }
    #autodrive.active::before {
      background: #00f5ff;
    }
    .game-title {
      position: fixed;
      top: 40px;
      left: 80px;
      z-index: 100;
      pointer-events: none;
    }
    .game-title-main {
      font-size: 25px;
      font-weight: normal;
      color: #ffeb3b;
      text-shadow: 
        2px 2px 0 #00f5ff,
        0 0 4px rgba(0, 245, 255, 0.4),
        0 0 8px rgba(255, 235, 59, 0.8);
      letter-spacing: 2px;
      font-family: 'Sixtyfour', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-bottom: 5px;
      filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.5));
    }
    .game-title-sub {
      font-size: 20px;
      font-weight: bold;
      color: #ff6b35;
      text-shadow: 
        0 0 8px #ff6b35,
        0 0 15px rgba(255, 107, 53, 0.5);
      letter-spacing: 4px;
      font-family: 'Share Tech Mono', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-left: 2px;
    }
  </style>
</head>
<body>
  <div class="game-title">
    <div class="game-title-main">Cyberpunk</div>
    <div class="game-title-sub">2048</div>
  </div>
  <div class="code-stream"></div>
  <div class="text-artifacts"></div>
  <div class="text-artifacts-extra"></div>
  <div class="geometric-lines"></div>
  <div class="top-right-controls">
    <button id="restart" title="Restart">REBOOT</button>
    <button id="autodrive">Autodrive</button>
  </div>
  <div id="ui" style="display: none;"></div>
  <div id="game-container">
    <canvas id="game"></canvas>
    <div class="score-display">
      <strong id="score">0</strong>
    </div>
  </div>
  <div class="high-score-system">
    HIGH SCORE: <strong id="highscore">0</strong>
  </div>
  <div id="gameOver">
    <div class="game-over-content">
      <div class="flatlined-text">FLATLINED</div>
      <div class="game-over-subtitle">SYSTEM FAILURE DETECTED</div>
      <div class="final-score">
        Final Score: <span id="finalScore">0</span>
      </div>
      <button id="restartGame">REBOOT SYSTEM</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const restartBtn = document.getElementById('restart');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const restartGameBtn = document.getElementById('restartGame');
    const autodriveBtn = document.getElementById('autodrive');

    const logicalSize = 500;
    const scale = window.devicePixelRatio || 1;
    canvas.width = logicalSize * scale;
    canvas.height = logicalSize * scale;
    canvas.style.width = logicalSize + 'px';
    canvas.style.height = logicalSize + 'px';
    ctx.scale(scale, scale);

    const size = 4;
    const gap = 10;
    const totalGaps = (size + 1) * gap;
    const tileSize = (logicalSize - totalGaps) / size;
    const cornerRadius = 8; // Rounded corner radius for tiles

    let board, score, highscore;
    let tiles = []; // Array of tile objects with position and animation data
    let isAnimating = false;
    let mergeAnimations = []; // Array of merge animations to render
    let gameOver = false;
    let autodriveActive = false;
    let autodriveTimeout = null;

    function initGame() {
      board = Array.from({ length: size }, () => Array(size).fill(0));
      tiles = [];
      mergeAnimations = [];
      score = 0;
      gameOver = false;
      highscore = parseInt(localStorage.getItem('highscore')) || 0;
      updateScores();
      hideGameOver();
      addTile();
      addTile();
      syncTilesFromBoard();
      drawBoard();
    }

    function showGameOver() {
      gameOver = true;
      finalScoreEl.textContent = score;
      gameOverEl.classList.add('show');
      // Stop autodrive when game ends
      if (autodriveActive) {
        autodriveActive = false;
        if (autodriveTimeout) {
          clearTimeout(autodriveTimeout);
          autodriveTimeout = null;
        }
        autodriveBtn.classList.remove('active');
        autodriveBtn.textContent = 'Autodrive';
      }
    }

    function hideGameOver() {
      gameOver = false;
      gameOverEl.classList.remove('show');
    }

    function hasAvailableMoves() {
      // Check if there are any empty cells
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (board[i][j] === 0) {
            return true;
          }
        }
      }

      // Check if there are any possible merges (adjacent tiles with same value)
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const current = board[i][j];
          // Check right neighbor
          if (j < size - 1 && board[i][j + 1] === current) {
            return true;
          }
          // Check bottom neighbor
          if (i < size - 1 && board[i + 1][j] === current) {
            return true;
          }
        }
      }

      return false;
    }

    function syncTilesFromBoard() {
      tiles = [];
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (board[i][j] !== 0) {
            tiles.push({
              value: board[i][j],
              row: i,
              col: j,
              prevRow: i,
              prevCol: j,
              isNew: false,
              mergedFrom: null
            });
          }
        }
      }
    }

    function updateScores() {
      scoreEl.textContent = score;
      highscoreEl.textContent = highscore;
    }

    function getRandomEmptyCell() {
      const empty = [];
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (board[i][j] === 0) empty.push({ i, j });
        }
      }
      return empty[Math.floor(Math.random() * empty.length)];
    }

    function addTile() {
      const cell = getRandomEmptyCell();
      if (cell) board[cell.i][cell.j] = Math.random() > 0.9 ? 4 : 2;
    }

    // Helper function to draw rounded rectangle
    function fillRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }

    function drawBoard() {
      ctx.clearRect(0, 0, logicalSize, logicalSize);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Draw empty cells
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const x = j * (tileSize + gap) + gap;
          const y = i * (tileSize + gap) + gap;
          ctx.fillStyle = 'rgba(15, 10, 25, 0.25)';
          fillRoundedRect(x, y, tileSize, tileSize, cornerRadius);
        }
      }

      // Draw animated tiles
      tiles.forEach(tile => {
        const startX = tile.prevCol * (tileSize + gap) + gap;
        const startY = tile.prevRow * (tileSize + gap) + gap;
        const endX = tile.col * (tileSize + gap) + gap;
        const endY = tile.row * (tileSize + gap) + gap;

        let x, y, scale = 1;

        if (isAnimating && (tile.prevRow !== tile.row || tile.prevCol !== tile.col)) {
          const progress = tile.animationProgress || 0;
          const easedProgress = easeOutCubic(progress);
          x = startX + (endX - startX) * easedProgress;
          y = startY + (endY - startY) * easedProgress;
          // Pop-in effect for new tiles
          if (tile.isNew) {
            scale = Math.min(1, progress * 1.2);
          }
        } else {
          x = endX;
          y = endY;
          if (tile.isNew) {
            scale = 1;
            tile.isNew = false;
          }
        }

        // Merge animation scale effect
        if (tile.mergeScale) {
          scale *= tile.mergeScale;
        }

        const hue = (Math.log2(tile.value) * 35 + 180) % 360;
        ctx.fillStyle = `hsl(${hue}, 100%, 55%)`;
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20 + (tile.mergeScale ? (tile.mergeScale - 1) * 30 : 0);

        const scaledSize = tileSize * scale;
        const offset = (tileSize - scaledSize) / 2;
        const scaledRadius = cornerRadius * scale; // Scale the radius proportionally
        fillRoundedRect(x + offset, y + offset, scaledSize, scaledSize, scaledRadius);
        ctx.shadowBlur = 0;

        ctx.font = 'bold 36px "Share Tech Mono"';
        ctx.fillStyle = '#00f5ff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeText(tile.value, x + tileSize / 2, y + tileSize / 2);
        ctx.fillText(tile.value, x + tileSize / 2, y + tileSize / 2);
      });

      // Draw merge particle effects
      mergeAnimations.forEach((merge, index) => {
        const x = merge.col * (tileSize + gap) + gap + tileSize / 2;
        const y = merge.row * (tileSize + gap) + gap + tileSize / 2;
        const progress = merge.progress;
        const radius = 15 + progress * 20;
        const alpha = 1 - progress;

        // Outer glow ring
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, `rgba(0, 245, 255, ${alpha * 0.8})`);
        gradient.addColorStop(0.5, `rgba(240, 0, 255, ${alpha * 0.4})`);
        gradient.addColorStop(1, `rgba(0, 245, 255, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Particle sparks
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 * i) / 8;
          const distance = progress * 30;
          const px = x + Math.cos(angle) * distance;
          const py = y + Math.sin(angle) * distance;
          
          ctx.fillStyle = `rgba(0, 245, 255, ${alpha})`;
          ctx.beginPath();
          ctx.arc(px, py, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        merge.progress += 0.05;
        if (merge.progress >= 1) {
          mergeAnimations.splice(index, 1);
        }
      });
    }

    // Easing function for smooth animation
    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function animateTiles() {
      if (!isAnimating) return;

      let allComplete = true;

      tiles.forEach(tile => {
        if (tile.prevRow !== tile.row || tile.prevCol !== tile.col) {
          tile.animationProgress = (tile.animationProgress || 0) + 0.08;
          if (tile.animationProgress < 1) {
            allComplete = false;
          } else {
            tile.animationProgress = 1;
            tile.prevRow = tile.row;
            tile.prevCol = tile.col;
          }
        }

        // Handle merge scale animation
        if (tile.mergedFrom) {
          if (!tile.mergeScale) {
            tile.mergeScale = 1;
            tile.mergeProgress = 0;
          }
          tile.mergeProgress = (tile.mergeProgress || 0) + 0.12;
          
          // Pulse effect: scale up then down
          if (tile.mergeProgress < 0.5) {
            tile.mergeScale = 1 + tile.mergeProgress * 0.4;
          } else {
            tile.mergeScale = 1.2 - (tile.mergeProgress - 0.5) * 0.4;
          }

          if (tile.mergeProgress >= 1) {
            tile.mergeScale = 1;
            tile.mergedFrom = null;
            tile.mergeProgress = null;
          } else {
            allComplete = false;
          }
        }
      });

      // Continue merge particle animations
      if (mergeAnimations.length > 0) {
        allComplete = false;
      }

      drawBoard();

      if (allComplete) {
        isAnimating = false;
        // Clean up animation properties
        tiles.forEach(tile => {
          tile.animationProgress = null;
          tile.mergeScale = null;
          tile.mergeProgress = null;
        });
      } else {
        requestAnimationFrame(animateTiles);
      }
    }

    function move(row, rowIndex, direction) {
      // Track original positions for animation
      const originalTiles = [];
      row.forEach((val, col) => {
        if (val !== 0) {
          originalTiles.push({
            value: val,
            originalCol: direction === 'left' ? col : direction === 'right' ? size - 1 - col : col,
            originalRow: rowIndex
          });
        }
      });

      const newRow = row.filter(v => v);
      const merged = [];
      let scoreIncrement = 0;
      for (let i = 0; i < newRow.length - 1; i++) {
        if (newRow[i] === newRow[i + 1]) {
          newRow[i] *= 2;
          scoreIncrement += newRow[i];
          merged.push({
            value: newRow[i],
            position: direction === 'left' ? i : direction === 'right' ? size - 1 - i : i,
            row: rowIndex
          });
          newRow[i + 1] = 0;
        }
      }
      const finalRow = newRow.filter(v => v).concat(Array(size - newRow.filter(v => v).length).fill(0));
      
      return { row: finalRow, merged, scoreIncrement };
    }

    function rotateBoardClockwise() {
      const newBoard = Array.from({ length: size }, () => Array(size).fill(0));
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          newBoard[j][size - 1 - i] = board[i][j];
        }
      }
      return newBoard;
    }

    function rotateBoardCounterClockwise() {
      const newBoard = Array.from({ length: size }, () => Array(size).fill(0));
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          newBoard[size - 1 - j][i] = board[i][j];
        }
      }
      return newBoard;
    }

    function performMove(direction) {
      // Save old board and tile positions
      const oldBoard = board.map(row => [...row]);
      tiles.forEach(tile => {
        tile.prevRow = tile.row;
        tile.prevCol = tile.col;
        tile.animationProgress = 0;
      });

      const newBoard = Array.from({ length: size }, () => Array(size).fill(0));
      const mergedPositions = [];
      let totalScoreIncrement = 0;

      if (direction === 'left') {
        for (let i = 0; i < size; i++) {
          const result = move(board[i], i, 'left');
          newBoard[i] = result.row;
          totalScoreIncrement += result.scoreIncrement || 0;
          result.merged.forEach(m => mergedPositions.push({ row: m.row, col: m.position }));
        }
      } else if (direction === 'right') {
        for (let i = 0; i < size; i++) {
          const result = move([...board[i]].reverse(), i, 'right');
          newBoard[i] = result.row.reverse();
          totalScoreIncrement += result.scoreIncrement || 0;
          result.merged.forEach(m => mergedPositions.push({ row: m.row, col: size - 1 - m.position }));
        }
      } else if (direction === 'up') {
        const rotated = rotateBoardCounterClockwise();
        for (let i = 0; i < size; i++) {
          const result = move(rotated[i], i, 'left');
          rotated[i] = result.row;
          totalScoreIncrement += result.scoreIncrement || 0;
          result.merged.forEach(m => {
            // After rotating back clockwise: newBoard[j][size - 1 - i] = rotated[i][j]
            // So rotated[i][m.position] becomes newBoard[m.position][size - 1 - i]
            const finalRow = m.position;
            const finalCol = size - 1 - i;
            mergedPositions.push({ row: finalRow, col: finalCol });
          });
        }
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            newBoard[j][size - 1 - i] = rotated[i][j];
          }
        }
      } else if (direction === 'down') {
        const rotated = rotateBoardClockwise();
        for (let i = 0; i < size; i++) {
          const result = move(rotated[i], i, 'left');
          rotated[i] = result.row;
          totalScoreIncrement += result.scoreIncrement || 0;
          result.merged.forEach(m => {
            // After rotating back counter-clockwise: newBoard[size - 1 - j][i] = rotated[i][j]
            // So rotated[i][m.position] becomes newBoard[size - 1 - m.position][i]
            const finalRow = size - 1 - m.position;
            const finalCol = i;
            mergedPositions.push({ row: finalRow, col: finalCol });
          });
        }
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            newBoard[size - 1 - j][i] = rotated[i][j];
          }
        }
      }

      // Update score with the total increment from all merges
      score += totalScoreIncrement;

      // Rebuild tiles array by matching old positions to new positions
      const newTiles = [];
      const usedOldTiles = new Set();

      // First pass: match tiles that moved or merged
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (newBoard[i][j] !== 0) {
            const isMerged = mergedPositions.some(m => m.row === i && m.col === j);
            const newVal = newBoard[i][j];
            
            // Try to find a matching old tile
            let matched = false;
            
            // For merged tiles, find the tile that's closer in the move direction
            // IMPORTANT: Always add merge animation when isMerged is true
            if (isMerged) {
              // Always add merge animation for merged positions
              mergeAnimations.push({ row: i, col: j, progress: 0 });
              
              const halfVal = newVal / 2;
              // Find tiles with half value that could merge, restricted to correct row/column
              let candidates = tiles.filter(t => {
                if (t.value !== halfVal || usedOldTiles.has(`${t.prevRow},${t.prevCol}`)) {
                  return false;
                }
                if (oldBoard[t.prevRow][t.prevCol] !== halfVal) {
                  return false;
                }
                // Restrict to same row for horizontal moves, same column for vertical moves
                if (direction === 'left' || direction === 'right') {
                  return t.prevRow === i;
                } else {
                  return t.prevCol === j;
                }
              });
              
              if (candidates.length >= 2) {
                // Pick the one closer to the merge position based on direction
                let bestTile = null;
                if (direction === 'left' || direction === 'right') {
                  bestTile = candidates.reduce((best, curr) => 
                    Math.abs(curr.prevCol - j) < Math.abs(best.prevCol - j) ? curr : best
                  );
                } else {
                  bestTile = candidates.reduce((best, curr) => 
                    Math.abs(curr.prevRow - i) < Math.abs(best.prevRow - i) ? curr : best
                  );
                }
                
                if (bestTile) {
                  bestTile.row = i;
                  bestTile.col = j;
                  bestTile.value = newVal;
                  bestTile.mergedFrom = true;
                  usedOldTiles.add(`${bestTile.prevRow},${bestTile.prevCol}`);
                  // Mark the other candidate for removal
                  candidates.forEach(t => {
                    if (t !== bestTile) {
                      usedOldTiles.add(`${t.prevRow},${t.prevCol}`);
                    }
                  });
                  matched = true;
                }
              } else if (candidates.length === 1) {
                // Edge case: only one candidate found (shouldn't happen normally, but handle it)
                const tile = candidates[0];
                tile.row = i;
                tile.col = j;
                tile.value = newVal;
                tile.mergedFrom = true;
                usedOldTiles.add(`${tile.prevRow},${tile.prevCol}`);
                matched = true;
              }
            }
            
            // For non-merged or if merge matching failed, try normal matching
            if (!matched) {
              // First check if tile is in same position (didn't move)
              if (oldBoard[i] && oldBoard[i][j] === newVal && !usedOldTiles.has(`${i},${j}`)) {
                const tile = tiles.find(t => t.prevRow === i && t.prevCol === j && t.value === newVal);
                if (tile) {
                  tile.row = i;
                  tile.col = j;
                  // If this is a merged position, mark it as merged
                  if (isMerged) {
                    tile.mergedFrom = true;
                    tile.value = newVal;
                  }
                  usedOldTiles.add(`${i},${j}`);
                  matched = true;
                }
              }
              
              // If still not matched, search for moved tiles based on direction
              if (!matched) {
                // Find candidate old positions based on move direction
                // For merged tiles, search for half value; for normal tiles, search for newVal
                const searchVal = isMerged ? newVal / 2 : newVal;
                const candidates = [];
                
                if (direction === 'left') {
                  // Moving left: tile at (i, j) could come from same row i, column >= j
                  for (let oldJ = j; oldJ < size; oldJ++) {
                    if (oldBoard[i][oldJ] === searchVal && !usedOldTiles.has(`${i},${oldJ}`)) {
                      candidates.push({ row: i, col: oldJ });
                    }
                  }
                } else if (direction === 'right') {
                  // Moving right: tile at (i, j) could come from same row i, column <= j
                  for (let oldJ = j; oldJ >= 0; oldJ--) {
                    if (oldBoard[i][oldJ] === searchVal && !usedOldTiles.has(`${i},${oldJ}`)) {
                      candidates.push({ row: i, col: oldJ });
                    }
                  }
                } else if (direction === 'up') {
                  // Moving up: tile at (i, j) could come from same column j, row >= i
                  for (let oldI = i; oldI < size; oldI++) {
                    if (oldBoard[oldI][j] === searchVal && !usedOldTiles.has(`${oldI},${j}`)) {
                      candidates.push({ row: oldI, col: j });
                    }
                  }
                } else if (direction === 'down') {
                  // Moving down: tile at (i, j) could come from same column j, row <= i
                  for (let oldI = i; oldI >= 0; oldI--) {
                    if (oldBoard[oldI][j] === searchVal && !usedOldTiles.has(`${oldI},${j}`)) {
                      candidates.push({ row: oldI, col: j });
                    }
                  }
                }
                
                // Find the closest candidate (most likely the one that moved)
                if (candidates.length > 0) {
                  let bestCandidate = candidates[0];
                  if (direction === 'left' || direction === 'right') {
                    bestCandidate = candidates.reduce((best, curr) => 
                      Math.abs(curr.col - j) < Math.abs(best.col - j) ? curr : best
                    );
                  } else {
                    bestCandidate = candidates.reduce((best, curr) => 
                      Math.abs(curr.row - i) < Math.abs(best.row - i) ? curr : best
                    );
                  }
                  
                  const tile = tiles.find(t => 
                    t.prevRow === bestCandidate.row && 
                    t.prevCol === bestCandidate.col && 
                    t.value === searchVal
                  );
                  
                  if (tile) {
                    tile.row = i;
                    tile.col = j;
                    // If this is a merged position, mark it as merged and update value
                    if (isMerged) {
                      tile.mergedFrom = true;
                      tile.value = newVal;
                    }
                    usedOldTiles.add(`${bestCandidate.row},${bestCandidate.col}`);
                    matched = true;
                  }
                }
              }
            }
            
            // If no match found, create new tile entry
            if (!matched) {
              newTiles.push({
                value: newVal,
                row: i,
                col: j,
                prevRow: i,
                prevCol: j,
                isNew: false,
                mergedFrom: isMerged
              });
              if (isMerged) {
                mergeAnimations.push({ row: i, col: j, progress: 0 });
              }
            }
          }
        }
      }

      // Remove tiles that were merged away or no longer exist
      tiles = tiles.filter(tile => {
        if (usedOldTiles.has(`${tile.prevRow},${tile.prevCol}`)) {
          // Check if this tile still exists at its new position
          return newBoard[tile.row] && newBoard[tile.row][tile.col] === tile.value;
        }
        // Tile wasn't used, check if it still exists at old position
        return oldBoard[tile.prevRow] && oldBoard[tile.prevRow][tile.prevCol] === tile.value &&
               newBoard[tile.prevRow] && newBoard[tile.prevRow][tile.prevCol] === tile.value;
      });

      // Add any new tiles
      tiles.push(...newTiles);

      // Update board
      board = newBoard;

      // Start animation
      isAnimating = true;
      requestAnimationFrame(animateTiles);
    }

    function rotateBoardClockwiseFrom(b) {
      const newBoard = Array.from({ length: size }, () => Array(size).fill(0));
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          newBoard[j][size - 1 - i] = b[i][j];
        }
      }
      return newBoard;
    }

    function rotateBoardCounterClockwiseFrom(b) {
      const newBoard = Array.from({ length: size }, () => Array(size).fill(0));
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          newBoard[size - 1 - j][i] = b[i][j];
        }
      }
      return newBoard;
    }

    function moveLeft() {
      performMove('left');
    }

    function moveRight() {
      performMove('right');
    }

    function moveUp() {
      performMove('up');
    }

    function moveDown() {
      performMove('down');
    }

    document.addEventListener('keydown', e => {
      if (isAnimating || gameOver || autodriveActive) return; // Prevent moves during animation, when game is over, or when autodrive is active
      
      const oldBoard = JSON.stringify(board);
      switch (e.key) {
        case 'ArrowLeft': moveLeft(); break;
        case 'ArrowRight': moveRight(); break;
        case 'ArrowUp': moveUp(); break;
        case 'ArrowDown': moveDown(); break;
      }
      if (JSON.stringify(board) !== oldBoard) {
        // Wait for animation to complete before adding new tile
        const checkAndAddTile = () => {
          if (!isAnimating) {
            addTile();
            syncTilesFromBoard();
            // Mark new tiles
            tiles.forEach(tile => {
              let wasThere = false;
              for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                  if (i === tile.row && j === tile.col && board[i][j] === tile.value) {
                    wasThere = true;
                    break;
                  }
                }
                if (wasThere) break;
              }
              if (!wasThere) {
                tile.isNew = true;
                tile.prevRow = tile.row;
                tile.prevCol = tile.col;
              }
            });
            drawBoard();
            updateScores();
            if (score > highscore) {
              highscore = score;
              localStorage.setItem('highscore', highscore);
            }
            
            // Check for game over after move completes
            if (!hasAvailableMoves()) {
              showGameOver();
            }
          } else {
            requestAnimationFrame(checkAndAddTile);
          }
        };
        requestAnimationFrame(checkAndAddTile);
      }
    });

    // Autodrive AI functions
    function evaluateMove(direction) {
      // Simulate the move to see the result
      const testBoard = board.map(row => [...row]);
      let testScore = score;
      let emptyCount = 0;
      let maxTile = 0;
      let cornerBonus = 0;

      // Simulate move
      if (direction === 'left') {
        for (let i = 0; i < size; i++) {
          const result = move(testBoard[i], i, 'left');
          testBoard[i] = result.row;
        }
      } else if (direction === 'right') {
        for (let i = 0; i < size; i++) {
          const result = move([...testBoard[i]].reverse(), i, 'right');
          testBoard[i] = result.row.reverse();
        }
      } else if (direction === 'up') {
        const rotated = rotateBoardCounterClockwiseFrom(testBoard);
        for (let i = 0; i < size; i++) {
          const result = move(rotated[i], i, 'left');
          rotated[i] = result.row;
        }
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            testBoard[j][size - 1 - i] = rotated[i][j];
          }
        }
      } else if (direction === 'down') {
        const rotated = rotateBoardClockwiseFrom(testBoard);
        for (let i = 0; i < size; i++) {
          const result = move(rotated[i], i, 'left');
          rotated[i] = result.row;
        }
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            testBoard[size - 1 - j][i] = rotated[i][j];
          }
        }
      }

      // Count empty cells and find max tile
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (testBoard[i][j] === 0) emptyCount++;
          if (testBoard[i][j] > maxTile) maxTile = testBoard[i][j];
          // Bonus for keeping high tiles in bottom-left corner
          if (i === size - 1 && j === 0 && testBoard[i][j] > 0) {
            cornerBonus += testBoard[i][j] * 10;
          }
        }
      }

      // Prefer moves that keep the corner pattern (down or left)
      let directionBonus = 0;
      if (direction === 'down' || direction === 'left') {
        directionBonus = 50;
      }

      // Calculate score: empty cells are good, merges are good, corner strategy is good
      return emptyCount * 10 + maxTile * 5 + cornerBonus + directionBonus;
    }

    function getBestMove() {
      const moves = ['up', 'down', 'left', 'right'];
      let bestMove = null;
      let bestScore = -1;

      for (const dir of moves) {
        const oldBoard = JSON.stringify(board);
        // Test if move is valid
        const testBoard = board.map(row => [...row]);
        if (dir === 'left') {
          for (let i = 0; i < size; i++) {
            const result = move(testBoard[i], i, 'left');
            testBoard[i] = result.row;
          }
        } else if (dir === 'right') {
          for (let i = 0; i < size; i++) {
            const result = move([...testBoard[i]].reverse(), i, 'right');
            testBoard[i] = result.row.reverse();
          }
        } else if (dir === 'up') {
          const rotated = rotateBoardCounterClockwiseFrom(testBoard);
          for (let i = 0; i < size; i++) {
            const result = move(rotated[i], i, 'left');
            rotated[i] = result.row;
          }
          for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
              testBoard[j][size - 1 - i] = rotated[i][j];
            }
          }
        } else if (dir === 'down') {
          const rotated = rotateBoardClockwiseFrom(testBoard);
          for (let i = 0; i < size; i++) {
            const result = move(rotated[i], i, 'left');
            rotated[i] = result.row;
          }
          for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
              testBoard[size - 1 - j][i] = rotated[i][j];
            }
          }
        }

        if (JSON.stringify(testBoard) !== oldBoard) {
          const score = evaluateMove(dir);
          if (score > bestScore) {
            bestScore = score;
            bestMove = dir;
          }
        }
      }

      return bestMove;
    }

    function makeAutodriveMove() {
      if (!autodriveActive || gameOver || isAnimating) {
        return;
      }

      const bestMove = getBestMove();
      if (bestMove) {
        // Save board state before move
        const oldBoard = JSON.stringify(board);
        
        // Trigger the move
        switch (bestMove) {
          case 'left': moveLeft(); break;
          case 'right': moveRight(); break;
          case 'up': moveUp(); break;
          case 'down': moveDown(); break;
        }

        // Check if board changed and add tile if needed (same logic as keydown handler)
        if (JSON.stringify(board) !== oldBoard) {
          // Wait for animation to complete before adding new tile
          const checkAndAddTile = () => {
            if (!isAnimating) {
              addTile();
              syncTilesFromBoard();
              // Mark new tiles
              tiles.forEach(tile => {
                let wasThere = false;
                for (let i = 0; i < size; i++) {
                  for (let j = 0; j < size; j++) {
                    if (i === tile.row && j === tile.col && board[i][j] === tile.value) {
                      wasThere = true;
                      break;
                    }
                  }
                  if (wasThere) break;
                }
                if (!wasThere) {
                  tile.isNew = true;
                  tile.prevRow = tile.row;
                  tile.prevCol = tile.col;
                }
              });
              drawBoard();
              updateScores();
              if (score > highscore) {
                highscore = score;
                localStorage.setItem('highscore', highscore);
              }
              
              // Check for game over after move completes
              if (!hasAvailableMoves()) {
                showGameOver();
              }
              
              // Schedule next move after a short delay
              if (autodriveActive && !gameOver) {
                autodriveTimeout = setTimeout(() => {
                  makeAutodriveMove();
                }, 300);
              }
            } else {
              requestAnimationFrame(checkAndAddTile);
            }
          };
          requestAnimationFrame(checkAndAddTile);
        } else {
          // Board didn't change, try next move immediately
          autodriveTimeout = setTimeout(() => {
            makeAutodriveMove();
          }, 100);
        }
      } else {
        // No valid moves, stop autodrive
        autodriveActive = false;
        autodriveBtn.classList.remove('active');
        autodriveBtn.textContent = 'Autodrive';
      }
    }

    function toggleAutodrive() {
      if (gameOver) return;

      autodriveActive = !autodriveActive;
      
      if (autodriveActive) {
        autodriveBtn.classList.add('active');
        autodriveBtn.textContent = 'Stop';
        makeAutodriveMove();
      } else {
        autodriveBtn.classList.remove('active');
        autodriveBtn.textContent = 'Autodrive';
        if (autodriveTimeout) {
          clearTimeout(autodriveTimeout);
          autodriveTimeout = null;
        }
      }
    }

    restartBtn.addEventListener('click', () => {
      // Trigger button animation
      restartBtn.classList.add('clicking');
      setTimeout(() => {
        restartBtn.classList.remove('clicking');
      }, 400);
      
      // Trigger board glitch effect
      canvas.classList.add('glitching');
      setTimeout(() => {
        canvas.classList.remove('glitching');
      }, 500);
      
      autodriveActive = false;
      if (autodriveTimeout) {
        clearTimeout(autodriveTimeout);
        autodriveTimeout = null;
      }
      autodriveBtn.classList.remove('active');
      autodriveBtn.textContent = 'Autodrive';
      
      // Delay game restart slightly to let animations play
      setTimeout(() => {
        initGame();
      }, 300);
    });
    restartGameBtn.addEventListener('click', () => {
      autodriveActive = false;
      if (autodriveTimeout) {
        clearTimeout(autodriveTimeout);
        autodriveTimeout = null;
      }
      autodriveBtn.classList.remove('active');
      autodriveBtn.textContent = 'Autodrive';
      initGame();
    });
    autodriveBtn.addEventListener('click', toggleAutodrive);

    // Initialize game after fonts are ready
    function startGame() {
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
          // Fonts are ready, initialize game
          initGame();
        }).catch(() => {
          // If promise fails, wait a bit and try anyway
          setTimeout(() => {
            initGame();
          }, 200);
        });
      } else {
        // Fallback for browsers without Font Loading API
        if (document.readyState === 'complete') {
          setTimeout(() => {
            initGame();
          }, 300);
        } else {
          window.addEventListener('load', () => {
            setTimeout(() => {
              initGame();
            }, 300);
          });
        }
      }
    }

    startGame();
  </script>
</body>
</html>
